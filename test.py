import os
import torch
import cv2
import numpy as np
from config import *
import nibabel as nib
from tqdm import tqdm
import torch.nn.functional as F
import math
import torchvision.transforms as transforms
import scipy.ndimage
import utils.dataset
from utils import dataset
from config import *

if task == "classification" and model == "DenseNet3D":
    from network.DenseNet3D import DenseNet3d as Net

if task == "classification" and model == "DenseNet":
    from network.DenseNet import DenseNet as Net

if task == "segmentation" and model == "UNet3D":
    from network.UNet3D import UNet3D as Net

net = Net().half().to(DEVICE)
net.eval()

RGB_transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225))
])

from sklearn.metrics import accuracy_score, roc_auc_score

neighbour_code_to_normals = [[[0, 0, 0]], [[0.125, 0.125, 0.125]],
                             [[-0.125, -0.125, 0.125]],
                             [[-0.25, -0.25, 0.0], [0.25, 0.25, -0.0]],
                             [[0.125, -0.125, 0.125]],
                             [[-0.25, -0.0, -0.25], [0.25, 0.0, 0.25]],
                             [[0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[0.5, 0.0, -0.0], [0.25, 0.25, 0.25],
                              [0.125, 0.125, 0.125]], [[-0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, 0.125, 0.125]],
                             [[-0.25, 0.0, 0.25], [-0.25, 0.0, 0.25]],
                             [[0.5, 0.0, 0.0], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.25, -0.25, 0.0], [0.25, -0.25, 0.0]],
                             [[0.5, 0.0, 0.0], [0.25, -0.25, 0.25],
                              [-0.125, 0.125, -0.125]],
                             [[-0.5, 0.0, 0.0], [-0.25, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[0.5, 0.0, 0.0], [0.5, 0.0, 0.0]],
                             [[0.125, -0.125, -0.125]],
                             [[0.0, -0.25, -0.25], [0.0, 0.25, 0.25]],
                             [[-0.125, -0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[0.0, -0.5, 0.0], [0.25, 0.25, 0.25],
                              [0.125, 0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[0.0, 0.0, -0.5], [0.25, 0.25, 0.25],
                              [-0.125, -0.125, -0.125]],
                             [[-0.125, -0.125, 0.125], [0.125, -0.125, 0.125],
                              [0.125, -0.125, -0.125]],
                             [[-0.125, -0.125, -0.125], [-0.25, -0.25, -0.25],
                              [0.25, 0.25, 0.25], [0.125, 0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[0.0, -0.25, -0.25], [0.0, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[-0.25, 0.0, 0.25], [-0.25, 0.0, 0.25],
                              [0.125, -0.125, -0.125]],
                             [[0.125, 0.125, 0.125], [0.375, 0.375, 0.375],
                              [0.0, -0.25, 0.25], [-0.25, 0.0, 0.25]],
                             [[0.125, -0.125, -0.125], [0.25, -0.25, 0.0],
                              [0.25, -0.25, 0.0]],
                             [[0.375, 0.375, 0.375], [0.0, 0.25, -0.25],
                              [-0.125, -0.125, -0.125], [-0.25, 0.25, 0.0]],
                             [[-0.5, 0.0, 0.0], [-0.125, -0.125, -0.125],
                              [-0.25, -0.25, -0.25], [0.125, 0.125, 0.125]],
                             [[-0.5, 0.0, 0.0], [-0.125, -0.125, -0.125],
                              [-0.25, -0.25, -0.25]], [[0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.0, -0.25, 0.25], [0.0, 0.25, -0.25]],
                             [[0.0, -0.5, 0.0], [0.125, 0.125, -0.125],
                              [0.25, 0.25, -0.25]],
                             [[0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [-0.25, -0.0, -0.25],
                              [0.25, 0.0, 0.25]],
                             [[0.0, -0.25, 0.25], [0.0, 0.25, -0.25],
                              [0.125, -0.125, 0.125]],
                             [[-0.375, -0.375, 0.375], [-0.0, 0.25, 0.25],
                              [0.125, 0.125, -0.125], [-0.25, -0.0, -0.25]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [-0.125, 0.125, 0.125]],
                             [[-0.0, 0.0, 0.5], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.25, 0.25, -0.25], [0.25, 0.25, -0.25],
                              [0.125, 0.125, -0.125], [-0.125, -0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [0.25, -0.25, 0.0],
                              [0.25, -0.25, 0.0]],
                             [[0.5, 0.0, 0.0], [0.25, -0.25, 0.25],
                              [-0.125, 0.125, -0.125], [0.125, -0.125, 0.125]],
                             [[0.0, 0.25, -0.25], [0.375, -0.375, -0.375],
                              [-0.125, 0.125, 0.125], [0.25, 0.25, 0.0]],
                             [[-0.5, 0.0, 0.0], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.25, -0.25, 0.0], [-0.25, 0.25, 0.0]],
                             [[0.0, 0.5, 0.0], [-0.25, 0.25, 0.25],
                              [0.125, -0.125, -0.125]],
                             [[0.0, 0.5, 0.0], [0.125, -0.125, 0.125],
                              [-0.25, 0.25, -0.25]],
                             [[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]],
                             [[0.25, -0.25, 0.0], [-0.25, 0.25, 0.0],
                              [0.125, -0.125, 0.125]],
                             [[-0.375, -0.375, -0.375], [-0.25, 0.0, 0.25],
                              [-0.125, -0.125, -0.125], [-0.25, 0.25, 0.0]],
                             [[0.125, 0.125, 0.125], [0.0, -0.5, 0.0],
                              [-0.25, -0.25, -0.25], [-0.125, -0.125, -0.125]],
                             [[0.0, -0.5, 0.0], [-0.25, -0.25, -0.25],
                              [-0.125, -0.125, -0.125]],
                             [[-0.125, 0.125, 0.125], [0.25, -0.25, 0.0],
                              [-0.25, 0.25, 0.0]],
                             [[0.0, 0.5, 0.0], [0.25, 0.25, -0.25],
                              [-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.375, 0.375, -0.375], [-0.25, -0.25, 0.0],
                              [-0.125, 0.125, -0.125], [-0.25, 0.0, 0.25]],
                             [[0.0, 0.5, 0.0], [0.25, 0.25, -0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.25, -0.25, 0.0], [-0.25, 0.25, 0.0],
                              [0.25, -0.25, 0.0], [0.25, -0.25, 0.0]],
                             [[-0.25, -0.25, 0.0], [-0.25, -0.25, 0.0],
                              [-0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.25, -0.25, 0.0],
                              [-0.25, -0.25, 0.0]],
                             [[-0.25, -0.25, 0.0], [-0.25, -0.25, 0.0]],
                             [[-0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [-0.25, -0.25, 0.0],
                              [0.25, 0.25, -0.0]],
                             [[0.0, -0.25, 0.25], [0.0, -0.25, 0.25]],
                             [[0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.0, -0.25, 0.25], [0.0, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.375, -0.375, 0.375], [0.0, -0.25, -0.25],
                              [-0.125, 0.125, -0.125], [0.25, 0.25, 0.0]],
                             [[-0.125, -0.125, 0.125], [-0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125],
                              [-0.125, 0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [-0.25, 0.0, 0.25],
                              [-0.25, 0.0, 0.25]],
                             [[0.5, 0.0, 0.0], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.0, 0.5, 0.0], [-0.25, 0.25, -0.25],
                              [0.125, -0.125, 0.125]],
                             [[-0.25, 0.25, -0.25], [-0.25, 0.25, -0.25],
                              [-0.125, 0.125, -0.125], [-0.125, 0.125, -0.125]],
                             [[-0.25, 0.0, -0.25], [0.375, -0.375, -0.375],
                              [0.0, 0.25, -0.25], [-0.125, 0.125, 0.125]],
                             [[0.5, 0.0, 0.0], [-0.25, 0.25, -0.25],
                              [0.125, -0.125, 0.125]],
                             [[-0.25, 0.0, 0.25], [0.25, 0.0, -0.25]],
                             [[-0.0, 0.0, 0.5], [-0.25, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [-0.25, 0.0, 0.25],
                              [0.25, 0.0, -0.25]],
                             [[-0.25, -0.0, -0.25], [-0.375, 0.375, 0.375],
                              [-0.25, -0.25, 0.0], [-0.125, 0.125, 0.125]],
                             [[0.0, 0.0, -0.5], [0.25, 0.25, -0.25],
                              [-0.125, -0.125, 0.125]],
                             [[-0.0, 0.0, 0.5], [0.0, 0.0, 0.5]],
                             [[0.125, 0.125, 0.125], [0.125, 0.125, 0.125],
                              [0.25, 0.25, 0.25], [0.0, 0.0, 0.5]],
                             [[0.125, 0.125, 0.125], [0.25, 0.25, 0.25],
                              [0.0, 0.0, 0.5]],
                             [[-0.25, 0.0, 0.25], [0.25, 0.0, -0.25],
                              [-0.125, 0.125, 0.125]],
                             [[-0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[-0.25, 0.0, 0.25], [-0.25, 0.0, 0.25],
                              [-0.25, 0.0, 0.25], [0.25, 0.0, -0.25]],
                             [[0.125, -0.125, 0.125], [0.25, 0.0, 0.25],
                              [0.25, 0.0, 0.25]],
                             [[0.25, 0.0, 0.25], [-0.375, -0.375, 0.375],
                              [-0.25, 0.25, 0.0], [-0.125, -0.125, 0.125]],
                             [[-0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.25, 0.0, 0.25],
                              [0.25, 0.0, 0.25]],
                             [[0.25, 0.0, 0.25], [0.25, 0.0, 0.25]],
                             [[-0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125],
                              [0.125, -0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [0.0, -0.25, 0.25],
                              [0.0, 0.25, -0.25]],
                             [[0.0, -0.5, 0.0], [0.125, 0.125, -0.125],
                              [0.25, 0.25, -0.25], [-0.125, -0.125, 0.125]],
                             [[0.0, -0.25, 0.25], [0.0, -0.25, 0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.0, -0.25, 0.25], [0.0, -0.25, 0.25],
                              [0.0, -0.25, 0.25], [0.0, 0.25, -0.25]],
                             [[0.0, 0.25, 0.25], [0.0, 0.25, 0.25],
                              [0.125, -0.125, -0.125]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [-0.125, -0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [-0.125, -0.125, 0.125], [0.125, 0.125, 0.125]],
                             [[-0.0, 0.0, 0.5], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [0.125, -0.125, -0.125]],
                             [[-0.0, 0.5, 0.0], [-0.25, 0.25, -0.25],
                              [0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125],
                              [0.125, -0.125, -0.125]],
                             [[0.0, -0.25, -0.25], [0.0, 0.25, 0.25],
                              [0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[0.5, 0.0, -0.0], [0.25, -0.25, -0.25],
                              [0.125, -0.125, -0.125]],
                             [[-0.25, 0.25, 0.25], [-0.125, 0.125, 0.125],
                              [-0.25, 0.25, 0.25], [0.125, -0.125, -0.125]],
                             [[0.375, -0.375, 0.375], [0.0, 0.25, 0.25],
                              [-0.125, 0.125, -0.125], [-0.25, 0.0, 0.25]],
                             [[0.0, -0.5, 0.0], [-0.25, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[-0.375, -0.375, 0.375], [0.25, -0.25, 0.0],
                              [0.0, 0.25, 0.25], [-0.125, -0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [-0.25, 0.25, 0.25],
                              [0.0, 0.0, 0.5]],
                             [[0.125, 0.125, 0.125], [0.0, 0.25, 0.25],
                              [0.0, 0.25, 0.25]],
                             [[0.0, 0.25, 0.25], [0.0, 0.25, 0.25]],
                             [[0.5, 0.0, -0.0], [0.25, 0.25, 0.25],
                              [0.125, 0.125, 0.125], [0.125, 0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [-0.125, -0.125, 0.125],
                              [0.125, 0.125, 0.125]],
                             [[-0.25, -0.0, -0.25], [0.25, 0.0, 0.25],
                              [0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[-0.25, -0.25, 0.0], [0.25, 0.25, -0.0],
                              [0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125]], [[0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.25, -0.25, 0.0], [0.25, 0.25, -0.0],
                              [0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[-0.25, -0.0, -0.25], [0.25, 0.0, 0.25],
                              [0.125, 0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [-0.125, -0.125, 0.125],
                              [0.125, 0.125, 0.125]],
                             [[0.5, 0.0, -0.0], [0.25, 0.25, 0.25],
                              [0.125, 0.125, 0.125], [0.125, 0.125, 0.125]],
                             [[0.0, 0.25, 0.25], [0.0, 0.25, 0.25]],
                             [[0.125, 0.125, 0.125], [0.0, 0.25, 0.25],
                              [0.0, 0.25, 0.25]],
                             [[-0.125, 0.125, 0.125], [-0.25, 0.25, 0.25],
                              [0.0, 0.0, 0.5]],
                             [[-0.375, -0.375, 0.375], [0.25, -0.25, 0.0],
                              [0.0, 0.25, 0.25], [-0.125, -0.125, 0.125]],
                             [[0.0, -0.5, 0.0], [-0.25, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[0.375, -0.375, 0.375], [0.0, 0.25, 0.25],
                              [-0.125, 0.125, -0.125], [-0.25, 0.0, 0.25]],
                             [[-0.25, 0.25, 0.25], [-0.125, 0.125, 0.125],
                              [-0.25, 0.25, 0.25], [0.125, -0.125, -0.125]],
                             [[0.5, 0.0, -0.0], [0.25, -0.25, -0.25],
                              [0.125, -0.125, -0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[0.0, -0.25, -0.25], [0.0, 0.25, 0.25],
                              [0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125],
                              [0.125, -0.125, -0.125]],
                             [[-0.0, 0.5, 0.0], [-0.25, 0.25, -0.25],
                              [0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [0.125, -0.125, -0.125]],
                             [[-0.0, 0.0, 0.5], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [-0.125, -0.125, 0.125], [0.125, 0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [-0.125, -0.125, 0.125]],
                             [[0.0, 0.25, 0.25], [0.0, 0.25, 0.25],
                              [0.125, -0.125, -0.125]],
                             [[0.0, -0.25, -0.25], [0.0, 0.25, 0.25],
                              [0.0, 0.25, 0.25], [0.0, 0.25, 0.25]],
                             [[0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.0, -0.25, 0.25], [0.0, -0.25, 0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.0, -0.5, 0.0], [0.125, 0.125, -0.125],
                              [0.25, 0.25, -0.25], [-0.125, -0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [0.0, -0.25, 0.25],
                              [0.0, 0.25, -0.25]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125],
                              [0.125, -0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.25, 0.0, 0.25], [0.25, 0.0, 0.25]],
                             [[0.125, 0.125, 0.125], [0.25, 0.0, 0.25],
                              [0.25, 0.0, 0.25]],
                             [[-0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.25, 0.0, 0.25], [-0.375, -0.375, 0.375],
                              [-0.25, 0.25, 0.0], [-0.125, -0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [0.25, 0.0, 0.25],
                              [0.25, 0.0, 0.25]],
                             [[-0.25, -0.0, -0.25], [0.25, 0.0, 0.25],
                              [0.25, 0.0, 0.25], [0.25, 0.0, 0.25]],
                             [[-0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[-0.25, 0.0, 0.25], [0.25, 0.0, -0.25],
                              [-0.125, 0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.25, 0.25, 0.25],
                              [0.0, 0.0, 0.5]],
                             [[0.125, 0.125, 0.125], [0.125, 0.125, 0.125],
                              [0.25, 0.25, 0.25], [0.0, 0.0, 0.5]],
                             [[-0.0, 0.0, 0.5], [0.0, 0.0, 0.5]],
                             [[0.0, 0.0, -0.5], [0.25, 0.25, -0.25],
                              [-0.125, -0.125, 0.125]],
                             [[-0.25, -0.0, -0.25], [-0.375, 0.375, 0.375],
                              [-0.25, -0.25, 0.0], [-0.125, 0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [-0.25, 0.0, 0.25],
                              [0.25, 0.0, -0.25]],
                             [[-0.0, 0.0, 0.5], [-0.25, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[-0.25, 0.0, 0.25], [0.25, 0.0, -0.25]],
                             [[0.5, 0.0, 0.0], [-0.25, 0.25, -0.25],
                              [0.125, -0.125, 0.125]],
                             [[-0.25, 0.0, -0.25], [0.375, -0.375, -0.375],
                              [0.0, 0.25, -0.25], [-0.125, 0.125, 0.125]],
                             [[-0.25, 0.25, -0.25], [-0.25, 0.25, -0.25],
                              [-0.125, 0.125, -0.125], [-0.125, 0.125, -0.125]],
                             [[-0.0, 0.5, 0.0], [-0.25, 0.25, -0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.5, 0.0, 0.0], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [-0.25, 0.0, 0.25],
                              [-0.25, 0.0, 0.25]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125],
                              [-0.125, 0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [-0.125, 0.125, 0.125]],
                             [[0.375, -0.375, 0.375], [0.0, -0.25, -0.25],
                              [-0.125, 0.125, -0.125], [0.25, 0.25, 0.0]],
                             [[0.0, -0.25, 0.25], [0.0, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.0, 0.0, 0.5], [0.25, -0.25, 0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.0, -0.25, 0.25], [0.0, -0.25, 0.25]],
                             [[-0.125, -0.125, 0.125], [-0.25, -0.25, 0.0],
                              [0.25, 0.25, -0.0]],
                             [[-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.125, -0.125, 0.125]],
                             [[-0.25, -0.25, 0.0], [-0.25, -0.25, 0.0]],
                             [[0.125, 0.125, 0.125], [-0.25, -0.25, 0.0],
                              [-0.25, -0.25, 0.0]],
                             [[-0.25, -0.25, 0.0], [-0.25, -0.25, 0.0],
                              [-0.125, -0.125, 0.125]],
                             [[-0.25, -0.25, 0.0], [-0.25, -0.25, 0.0],
                              [-0.25, -0.25, 0.0], [0.25, 0.25, -0.0]],
                             [[0.0, 0.5, 0.0], [0.25, 0.25, -0.25],
                              [-0.125, -0.125, 0.125]],
                             [[-0.375, 0.375, -0.375], [-0.25, -0.25, 0.0],
                              [-0.125, 0.125, -0.125], [-0.25, 0.0, 0.25]],
                             [[0.0, 0.5, 0.0], [0.25, 0.25, -0.25],
                              [-0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [0.25, -0.25, 0.0],
                              [-0.25, 0.25, 0.0]],
                             [[0.0, -0.5, 0.0], [-0.25, -0.25, -0.25],
                              [-0.125, -0.125, -0.125]],
                             [[0.125, 0.125, 0.125], [0.0, -0.5, 0.0],
                              [-0.25, -0.25, -0.25], [-0.125, -0.125, -0.125]],
                             [[-0.375, -0.375, -0.375], [-0.25, 0.0, 0.25],
                              [-0.125, -0.125, -0.125], [-0.25, 0.25, 0.0]],
                             [[0.25, -0.25, 0.0], [-0.25, 0.25, 0.0],
                              [0.125, -0.125, 0.125]],
                             [[0.0, 0.5, 0.0], [0.0, -0.5, 0.0]],
                             [[0.0, 0.5, 0.0], [0.125, -0.125, 0.125],
                              [-0.25, 0.25, -0.25]],
                             [[0.0, 0.5, 0.0], [-0.25, 0.25, 0.25],
                              [0.125, -0.125, -0.125]],
                             [[0.25, -0.25, 0.0], [-0.25, 0.25, 0.0]],
                             [[-0.5, 0.0, 0.0], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.0, 0.25, -0.25], [0.375, -0.375, -0.375],
                              [-0.125, 0.125, 0.125], [0.25, 0.25, 0.0]],
                             [[0.5, 0.0, 0.0], [0.25, -0.25, 0.25],
                              [-0.125, 0.125, -0.125], [0.125, -0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [0.25, -0.25, 0.0],
                              [0.25, -0.25, 0.0]],
                             [[0.25, 0.25, -0.25], [0.25, 0.25, -0.25],
                              [0.125, 0.125, -0.125], [-0.125, -0.125, 0.125]],
                             [[-0.0, 0.0, 0.5], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125],
                              [-0.125, 0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[-0.375, -0.375, 0.375], [-0.0, 0.25, 0.25],
                              [0.125, 0.125, -0.125], [-0.25, -0.0, -0.25]],
                             [[0.0, -0.25, 0.25], [0.0, 0.25, -0.25],
                              [0.125, -0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [-0.25, -0.0, -0.25],
                              [0.25, 0.0, 0.25]],
                             [[0.125, -0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.0, -0.5, 0.0], [0.125, 0.125, -0.125],
                              [0.25, 0.25, -0.25]],
                             [[0.0, -0.25, 0.25], [0.0, 0.25, -0.25]],
                             [[0.125, 0.125, 0.125], [0.125, -0.125, 0.125]],
                             [[0.125, -0.125, 0.125]],
                             [[-0.5, 0.0, 0.0], [-0.125, -0.125, -0.125],
                              [-0.25, -0.25, -0.25]],
                             [[-0.5, 0.0, 0.0], [-0.125, -0.125, -0.125],
                              [-0.25, -0.25, -0.25], [0.125, 0.125, 0.125]],
                             [[0.375, 0.375, 0.375], [0.0, 0.25, -0.25],
                              [-0.125, -0.125, -0.125], [-0.25, 0.25, 0.0]],
                             [[0.125, -0.125, -0.125], [0.25, -0.25, 0.0],
                              [0.25, -0.25, 0.0]],
                             [[0.125, 0.125, 0.125], [0.375, 0.375, 0.375],
                              [0.0, -0.25, 0.25], [-0.25, 0.0, 0.25]],
                             [[-0.25, 0.0, 0.25], [-0.25, 0.0, 0.25],
                              [0.125, -0.125, -0.125]],
                             [[0.0, -0.25, -0.25], [0.0, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[-0.125, 0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[-0.125, -0.125, -0.125], [-0.25, -0.25, -0.25],
                              [0.25, 0.25, 0.25], [0.125, 0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [0.125, -0.125, 0.125],
                              [0.125, -0.125, -0.125]],
                             [[0.0, 0.0, -0.5], [0.25, 0.25, 0.25],
                              [-0.125, -0.125, -0.125]],
                             [[0.125, -0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[0.0, -0.5, 0.0], [0.25, 0.25, 0.25],
                              [0.125, 0.125, 0.125]],
                             [[-0.125, -0.125, 0.125], [0.125, -0.125, -0.125]],
                             [[0.0, -0.25, -0.25], [0.0, 0.25, 0.25]],
                             [[0.125, -0.125, -0.125]],
                             [[0.5, 0.0, 0.0], [0.5, 0.0, 0.0]],
                             [[-0.5, 0.0, 0.0], [-0.25, 0.25, 0.25],
                              [-0.125, 0.125, 0.125]],
                             [[0.5, 0.0, 0.0], [0.25, -0.25, 0.25],
                              [-0.125, 0.125, -0.125]],
                             [[0.25, -0.25, 0.0], [0.25, -0.25, 0.0]],
                             [[0.5, 0.0, 0.0], [-0.25, -0.25, 0.25],
                              [-0.125, -0.125, 0.125]],
                             [[-0.25, 0.0, 0.25], [-0.25, 0.0, 0.25]],
                             [[0.125, 0.125, 0.125], [-0.125, 0.125, 0.125]],
                             [[-0.125, 0.125, 0.125]],
                             [[0.5, 0.0, -0.0], [0.25, 0.25, 0.25],
                              [0.125, 0.125, 0.125]],
                             [[0.125, -0.125, 0.125], [-0.125, -0.125, 0.125]],
                             [[-0.25, -0.0, -0.25], [0.25, 0.0, 0.25]],
                             [[0.125, -0.125, 0.125]],
                             [[-0.25, -0.25, 0.0], [0.25, 0.25, -0.0]],
                             [[-0.125, -0.125, 0.125]], [[0.125, 0.125, 0.125]],
                             [[0, 0, 0]]]


def compute_surface_distances(mask_gt, mask_pred, spacing_mm):
    """Compute closest distances from all surface points to the other surface.

  Finds all surface elements "surfels" in the ground truth mask `mask_gt` and
  the predicted mask `mask_pred`, computes their area in mm^2 and the distance
  to the closest point on the other surface. It returns two sorted lists of
  distances together with the corresponding surfel areas. If one of the masks
  is empty, the corresponding lists are empty and all distances in the other
  list are `inf` 
  
  Args:
    mask_gt: 3-dim Numpy array of type bool. The ground truth mask.
    mask_pred: 3-dim Numpy array of type bool. The predicted mask.
    spacing_mm: 3-element list-like structure. Voxel spacing in x0, x1 and x2
        direction 

  Returns:
    A dict with 
    "distances_gt_to_pred": 1-dim numpy array of type float. The distances in mm
        from all ground truth surface elements to the predicted surface, 
        sorted from smallest to largest
    "distances_pred_to_gt": 1-dim numpy array of type float. The distances in mm
        from all predicted surface elements to the ground truth surface, 
        sorted from smallest to largest 
    "surfel_areas_gt": 1-dim numpy array of type float. The area in mm^2 of 
        the ground truth surface elements in the same order as 
        distances_gt_to_pred
    "surfel_areas_pred": 1-dim numpy array of type float. The area in mm^2 of 
        the predicted surface elements in the same order as 
        distances_pred_to_gt
  """

    # compute the area for all 256 possible surface elements
    # (given a 2x2x2 neighbourhood) according to the spacing_mm
    neighbour_code_to_surface_area = np.zeros([256])
    for code in range(256):
        normals = np.array(neighbour_code_to_normals[code])
        sum_area = 0
        for normal_idx in range(normals.shape[0]):
            # normal vector
            n = np.zeros([3])
            n[0] = normals[normal_idx, 0] * spacing_mm[1] * spacing_mm[2]
            n[1] = normals[normal_idx, 1] * spacing_mm[0] * spacing_mm[2]
            n[2] = normals[normal_idx, 2] * spacing_mm[0] * spacing_mm[1]
            area = np.linalg.norm(n)
            sum_area += area
        neighbour_code_to_surface_area[code] = sum_area

    # compute the bounding box of the masks to trim
    # the volume to the smallest possible processing subvolume
    mask_all = mask_gt | mask_pred
    bbox_min = np.zeros(3, np.int64)
    bbox_max = np.zeros(3, np.int64)

    # max projection to the x0-axis
    proj_0 = np.max(np.max(mask_all, axis=2), axis=1)
    idx_nonzero_0 = np.nonzero(proj_0)[0]
    if len(idx_nonzero_0) == 0:
        return {
            "distances_gt_to_pred": np.array([]),
            "distances_pred_to_gt": np.array([]),
            "surfel_areas_gt": np.array([]),
            "surfel_areas_pred": np.array([])
        }

    bbox_min[0] = np.min(idx_nonzero_0)
    bbox_max[0] = np.max(idx_nonzero_0)

    # max projection to the x1-axis
    proj_1 = np.max(np.max(mask_all, axis=2), axis=0)
    idx_nonzero_1 = np.nonzero(proj_1)[0]
    bbox_min[1] = np.min(idx_nonzero_1)
    bbox_max[1] = np.max(idx_nonzero_1)

    # max projection to the x2-axis
    proj_2 = np.max(np.max(mask_all, axis=1), axis=0)
    idx_nonzero_2 = np.nonzero(proj_2)[0]
    bbox_min[2] = np.min(idx_nonzero_2)
    bbox_max[2] = np.max(idx_nonzero_2)

    print("bounding box min = {}".format(bbox_min))
    print("bounding box max = {}".format(bbox_max))

    # crop the processing subvolume.
    # we need to zeropad the cropped region with 1 voxel at the lower,
    # the right and the back side. This is required to obtain the "full"
    # convolution result with the 2x2x2 kernel
    cropmask_gt = np.zeros((bbox_max - bbox_min) + 2, np.uint8)
    cropmask_pred = np.zeros((bbox_max - bbox_min) + 2, np.uint8)

    cropmask_gt[0:-1, 0:-1, 0:-1] = mask_gt[bbox_min[0]:bbox_max[0] + 1,
                                            bbox_min[1]:bbox_max[1] + 1,
                                            bbox_min[2]:bbox_max[2] + 1]

    cropmask_pred[0:-1, 0:-1, 0:-1] = mask_pred[bbox_min[0]:bbox_max[0] + 1,
                                                bbox_min[1]:bbox_max[1] + 1,
                                                bbox_min[2]:bbox_max[2] + 1]

    # compute the neighbour code (local binary pattern) for each voxel
    # the resultsing arrays are spacially shifted by minus half a voxel in each axis.
    # i.e. the points are located at the corners of the original voxels
    kernel = np.array([[[128, 64], [32, 16]], [[8, 4], [2, 1]]])
    neighbour_code_map_gt = scipy.ndimage.filters.correlate(cropmask_gt.astype(
        np.uint8),
                                                            kernel,
                                                            mode="constant",
                                                            cval=0)
    neighbour_code_map_pred = scipy.ndimage.filters.correlate(
        cropmask_pred.astype(np.uint8), kernel, mode="constant", cval=0)

    # create masks with the surface voxels
    borders_gt = ((neighbour_code_map_gt != 0) & (neighbour_code_map_gt != 255))
    borders_pred = ((neighbour_code_map_pred != 0) &
                    (neighbour_code_map_pred != 255))

    # compute the distance transform (closest distance of each voxel to the surface voxels)
    if borders_gt.any():
        distmap_gt = scipy.ndimage.morphology.distance_transform_edt(
            ~borders_gt, sampling=spacing_mm)
    else:
        distmap_gt = np.Inf * np.ones(borders_gt.shape)

    if borders_pred.any():
        distmap_pred = scipy.ndimage.morphology.distance_transform_edt(
            ~borders_pred, sampling=spacing_mm)
    else:
        distmap_pred = np.Inf * np.ones(borders_pred.shape)

    # compute the area of each surface element
    surface_area_map_gt = neighbour_code_to_surface_area[neighbour_code_map_gt]
    surface_area_map_pred = neighbour_code_to_surface_area[
        neighbour_code_map_pred]

    # create a list of all surface elements with distance and area
    distances_gt_to_pred = distmap_pred[borders_gt]
    distances_pred_to_gt = distmap_gt[borders_pred]
    surfel_areas_gt = surface_area_map_gt[borders_gt]
    surfel_areas_pred = surface_area_map_pred[borders_pred]

    # sort them by distance
    if distances_gt_to_pred.shape != (0,):
        sorted_surfels_gt = np.array(
            sorted(zip(distances_gt_to_pred, surfel_areas_gt)))
        distances_gt_to_pred = sorted_surfels_gt[:, 0]
        surfel_areas_gt = sorted_surfels_gt[:, 1]

    if distances_pred_to_gt.shape != (0,):
        sorted_surfels_pred = np.array(
            sorted(zip(distances_pred_to_gt, surfel_areas_pred)))
        distances_pred_to_gt = sorted_surfels_pred[:, 0]
        surfel_areas_pred = sorted_surfels_pred[:, 1]

    return {
        "distances_gt_to_pred": distances_gt_to_pred,
        "distances_pred_to_gt": distances_pred_to_gt,
        "surfel_areas_gt": surfel_areas_gt,
        "surfel_areas_pred": surfel_areas_pred
    }


def compute_average_surface_distance(surface_distances):
    distances_gt_to_pred = surface_distances["distances_gt_to_pred"]
    distances_pred_to_gt = surface_distances["distances_pred_to_gt"]
    surfel_areas_gt = surface_distances["surfel_areas_gt"]
    surfel_areas_pred = surface_distances["surfel_areas_pred"]
    average_distance_gt_to_pred = np.sum(
        distances_gt_to_pred * surfel_areas_gt) / np.sum(surfel_areas_gt)
    average_distance_pred_to_gt = np.sum(
        distances_pred_to_gt * surfel_areas_pred) / np.sum(surfel_areas_pred)
    return (average_distance_gt_to_pred, average_distance_pred_to_gt)


def compute_robust_hausdorff(surface_distances, percent):
    distances_gt_to_pred = surface_distances["distances_gt_to_pred"]
    distances_pred_to_gt = surface_distances["distances_pred_to_gt"]
    surfel_areas_gt = surface_distances["surfel_areas_gt"]
    surfel_areas_pred = surface_distances["surfel_areas_pred"]
    if len(distances_gt_to_pred) > 0:
        surfel_areas_cum_gt = np.cumsum(surfel_areas_gt) / np.sum(
            surfel_areas_gt)
        idx = np.searchsorted(surfel_areas_cum_gt, percent / 100.0)
        perc_distance_gt_to_pred = distances_gt_to_pred[min(
            idx,
            len(distances_gt_to_pred) - 1)]
    else:
        perc_distance_gt_to_pred = np.Inf

    if len(distances_pred_to_gt) > 0:
        surfel_areas_cum_pred = np.cumsum(surfel_areas_pred) / np.sum(
            surfel_areas_pred)
        idx = np.searchsorted(surfel_areas_cum_pred, percent / 100.0)
        perc_distance_pred_to_gt = distances_pred_to_gt[min(
            idx,
            len(distances_pred_to_gt) - 1)]
    else:
        perc_distance_pred_to_gt = np.Inf

    return max(perc_distance_gt_to_pred, perc_distance_pred_to_gt)


def compute_surface_overlap_at_tolerance(surface_distances, tolerance_mm):
    distances_gt_to_pred = surface_distances["distances_gt_to_pred"]
    distances_pred_to_gt = surface_distances["distances_pred_to_gt"]
    surfel_areas_gt = surface_distances["surfel_areas_gt"]
    surfel_areas_pred = surface_distances["surfel_areas_pred"]
    rel_overlap_gt = np.sum(surfel_areas_gt[
        distances_gt_to_pred <= tolerance_mm]) / np.sum(surfel_areas_gt)
    rel_overlap_pred = np.sum(surfel_areas_pred[
        distances_pred_to_gt <= tolerance_mm]) / np.sum(surfel_areas_pred)
    return (rel_overlap_gt, rel_overlap_pred)


def compute_surface_dice_at_tolerance(surface_distances, tolerance_mm):
    distances_gt_to_pred = surface_distances["distances_gt_to_pred"]
    distances_pred_to_gt = surface_distances["distances_pred_to_gt"]
    surfel_areas_gt = surface_distances["surfel_areas_gt"]
    surfel_areas_pred = surface_distances["surfel_areas_pred"]
    overlap_gt = np.sum(surfel_areas_gt[distances_gt_to_pred <= tolerance_mm])
    overlap_pred = np.sum(
        surfel_areas_pred[distances_pred_to_gt <= tolerance_mm])
    surface_dice = (overlap_gt + overlap_pred) / (np.sum(surfel_areas_gt) +
                                                  np.sum(surfel_areas_pred))
    return surface_dice


def compute_dice_coefficient(mask_gt, mask_pred):
    """Compute soerensen-dice coefficient.

  compute the soerensen-dice coefficient between the ground truth mask `mask_gt`
  and the predicted mask `mask_pred`. 
  
  Args:
    mask_gt: 3-dim Numpy array of type bool. The ground truth mask.
    mask_pred: 3-dim Numpy array of type bool. The predicted mask.

  Returns:
    the dice coeffcient as float. If both masks are empty, the result is NaN
  """
    volume_sum = mask_gt.sum() + mask_pred.sum()
    if volume_sum == 0:
        return np.NaN
    volume_intersect = (mask_gt & mask_pred).sum()
    return 2 * volume_intersect / volume_sum


def getACC(y_true, y_score, task, threshold=0.5):
    '''Accuracy metric.
    :param y_true: the ground truth labels, shape: (n_samples, n_labels) or (n_samples,) if n_labels==1
    :param y_score: the predicted score of each class,
    shape: (n_samples, n_labels) or (n_samples, n_classes) or (n_samples,) if n_labels==1 or n_classes==1
    :param task: the task of current dataset
    :param threshold: the threshold for multilabel and binary-class tasks
    '''
    print("y_score: ", y_score)
    y_true = y_true.squeeze()
    y_score = y_score.squeeze()

    if task == 'multi-label, binary-class':
        y_pre = y_score > threshold
        acc = 0
        for label in range(y_true.shape[1]):
            label_acc = accuracy_score(y_true[:, label], y_pre[:, label])
            acc += label_acc
        ret = acc / y_true.shape[1]
    elif task == 'binary-class':
        if y_score.ndim == 2:
            y_score = y_score[:, -1]
        else:
            assert y_score.ndim == 1
        ret = accuracy_score(y_true, y_score > threshold)
    else:
        ret = accuracy_score(y_true, np.argmax(y_score, axis=-1))

    return ret


def getAUC(y_true, y_score, task):
    '''AUC metric.
    :param y_true: the ground truth labels, shape: (n_samples, n_labels) or (n_samples,) if n_labels==1
    :param y_score: the predicted score of each class,
    shape: (n_samples, n_labels) or (n_samples, n_classes) or (n_samples,) if n_labels==1 or n_classes==1
    :param task: the task of current dataset
    '''
    y_true = y_true.squeeze()
    y_score = y_score.squeeze()

    if task == 'multi-label, binary-class':
        auc = 0
        for i in range(y_score.shape[1]):
            label_auc = roc_auc_score(y_true[:, i], y_score[:, i])
            auc += label_auc
        ret = auc / y_score.shape[1]
    elif task == 'binary-class':
        if y_score.ndim == 2:
            y_score = y_score[:, -1]
        else:
            assert y_score.ndim == 1
        ret = roc_auc_score(y_true, y_score)
    else:
        auc = 0
        for i in range(y_score.shape[1]):
            y_true_binary = (y_true == i).astype(float)
            y_score_binary = y_score[:, i]
            auc += roc_auc_score(y_true_binary, y_score_binary)
        ret = auc / y_score.shape[1]

    return ret


def RGBClsInference(file_path):
    state_dict = torch.load(model_path)
    net.load_state_dict(state_dict)
    net.eval()

    image = cv2.imread(file_path)
    image = cv2.resize(image, (img_size[0], img_size[1]))
    image = RGB_transform(image).to(DEVICE)
    image1 = torch.reshape(image, (1, channel, img_size[0], img_size[1]))
    output = net(image1)
    pred = torch.argmax(output.data, dim=1)
    pred = int(pred.clone().detach().cpu().numpy())

    return pred


def CTClsInference(file_path):
    state_dict = torch.load(model_path)
    net.load_state_dict(state_dict)
    net.eval()
    image = utils.dataset.read_nifti_cls_file(file_path, rotate)

    if len(image.shape) == 3:
        # 增加一维channel，确保tensor输入为NCDHW
        image = np.expand_dims(image, axis=0)
        image = torch.from_numpy(image)
        image = torch.permute(image, (0, 3, 1, 2))
    else:
        image = image.astype(np.float32)
        image = torch.from_numpy(image)
        image = torch.permute(image, (3, 2, 0, 1))
    image1 = torch.reshape(
        image, (1, channel, img_size[2], img_size[0], img_size[1])).to(DEVICE)
    output = net(image1)
    pred = torch.argmax(output.data, dim=1)
    pred = int(pred.clone().detach().cpu().numpy())

    return pred


if data_random_split:
    from utils.dataset import load_random_split_data as load_data
    trainloader, testloader, num_examples = load_data(data_path)

else:
    from utils.dataset import load_data_from_path as load_data
    trainloader, testloader, num_examples = load_data(trainset, testset)

from utils.dataset import XusCTClsDataset, XusRGBClsImage, XusCTSegDataset
from torch.utils import data


def xus_clstest(test_dir, test_files, test_model_params):
    print(num_classes)
    total_label = None
    total_pred = None
    net.load_state_dict(torch.load(test_model_params))

    for file in test_files:
        tmp_file = os.path.join(test_dir, file)

        if task == "classification" and data_type == "CT":
            test_dataset = XusCTClsDataset(tmp_file)

        if task == "classification" and data_type == "RGB":
            test_dataset = XusRGBClsImage(tmp_file)

        testloader = data.DataLoader(test_dataset, batch_size, num_workers=0)

        for images, labels in tqdm(testloader):
            images, labels = images.to(DEVICE), labels.to(DEVICE)
            outputs = net(images)

            test_len = len(outputs)
            label_mat = np.zeros((test_len, num_classes))
            for ind in range(test_len):
                label_ind = labels[ind]
                label_mat[ind, label_ind] = 1

            if class_number_type == "binary-class":
                if total_label is None:
                    total_label = labels.cpu().detach().numpy()
                else:
                    total_label = np.append(total_label,
                                            labels.cpu().detach().numpy())

            else:
                if total_label is None:
                    total_label = label_mat
                else:
                    total_label = np.vstack([total_label, label_mat])

            if total_pred is None:
                total_pred = outputs.cpu().detach().numpy()
            else:
                total_pred = np.vstack(
                    [total_pred, outputs.cpu().detach().numpy()])

    acc = getACC(total_label, total_pred, task=class_number_type)
    auc = getAUC(total_label, total_pred, task=class_number_type)
    print("acc, auc: ", acc, auc)


def ClsTest():
    global pred, label
    if labeled:
        correct, total, accuracy = 0, 0, 0.0
        for roots, dirs, files in os.walk(test_path):
            for file in files:
                file_path = os.path.join(roots, file)
                print("文件路径： ", file_path)
                if data_type == "RGB":
                    pred = RGBClsInference(file_path)
                    print("预测标签： ", pred)
                    label = int(dataset.get_cls_label(file_path))
                    print("真实标签： ", label)
                if data_type == "CT":
                    pred = CTClsInference(file_path)
                    print("预测标签： ", pred)
                    label = int(dataset.get_cls_label(file_path))
                    print("真实标签： ", label)
                if pred == label:
                    correct += 1
                total += 1
        accuracy = correct / total
        print("测试精度为： ", accuracy)
    else:
        for roots, dirs, files in os.walk(test_path):
            for file in files:
                file_path = os.path.join(roots, file)
                print("文件路径： ", file_path)
                if data_type == "RGB":
                    pred = RGBClsInference(file_path)
                    print("预测标签： ", pred)
                if data_type == "CT":
                    pred = CTClsInference(file_path)
                    print("预测标签： ", pred)


def test_single_case(net, image, stride_xy, stride_z, patch_size, n_classes=1):
    c, hh, ww, dd = image.shape

    sx = math.ceil((hh - patch_size[0]) / stride_xy) + 1
    sy = math.ceil((ww - patch_size[1]) / stride_xy) + 1
    sz = math.ceil((dd - patch_size[2]) / stride_z) + 1
    # print("{}, {}, {}".format(sx, sy, sz))
    score_map = np.zeros((n_classes,) + image.shape[1:]).astype(np.float32)
    cnt = np.zeros(image.shape[1:]).astype(np.float32)

    for x in range(0, sx):
        xs = min(stride_xy * x, hh - patch_size[0])
        for y in range(0, sy):
            ys = min(stride_xy * y, ww - patch_size[1])
            for z in range(0, sz):
                zs = min(stride_z * z, dd - patch_size[2])
                test_patch = image[:, xs:xs + patch_size[0],
                                   ys:ys + patch_size[1], zs:zs + patch_size[2]]
                test_patch = np.expand_dims(test_patch,
                                            axis=0).astype(np.float32)
                test_patch = torch.from_numpy(test_patch).cuda()
                y1 = net(test_patch)
                y = F.softmax(y1, dim=1)
                y = y.cpu().data.numpy()
                y = y[0, :, :, :, :]
                score_map[:, xs:xs+patch_size[0], ys:ys+patch_size[1], zs:zs+patch_size[2]] \
                  = score_map[:, xs:xs+patch_size[0], ys:ys+patch_size[1], zs:zs+patch_size[2]] + y
                cnt[xs:xs+patch_size[0], ys:ys+patch_size[1], zs:zs+patch_size[2]] \
                  = cnt[xs:xs+patch_size[0], ys:ys+patch_size[1], zs:zs+patch_size[2]] + 1
    score_map = score_map / np.expand_dims(cnt, axis=0)
    label_map = np.argmax(score_map, axis=0)
    return label_map, score_map


def test_all_case(net,
                  srcpath,
                  patch_size=(112, 112, 80),
                  stride_xy=18,
                  stride_z=4,
                  save_result=True,
                  test_save_path=None):
    imgpath = os.path.join(srcpath, "images")
    labelpath = os.path.join(srcpath, "labels")
    label_list = []
    img_path_list = []

    for img_name in os.listdir(imgpath):
        img_path = os.path.join(imgpath, img_name)
        img_path_list.append(img_path)

    if os.path.exists(labelpath):
        print(
            "<<<<<<<<<<<<<<<<<<<<Waiting For Data Loading<<<<<<<<<<<<<<<<<<<<" +
            "\n")
        for label_name in tqdm(os.listdir(labelpath)):
            label_path = os.path.join(labelpath, label_name)
            label_list.append(utils.dataset.get_nifti_seg_label(label_path))
        print("<<<<<<<<<<<<<<<<<<<<Data Loading Complete<<<<<<<<<<<<<<<<<<<<" +
              "\n")

        print("<<<<<<<<<<<<<<<<<<<<Waiting For Inference<<<<<<<<<<<<<<<<<<<<" +
              "\n")

        for index, img_path in enumerate(tqdm(img_path_list)):
            image = utils.dataset.read_nifti_seg_file(img_path)
            label = label_list[index]

            prediction, score_map = test_single_case(net,
                                                     image,
                                                     stride_xy,
                                                     stride_z,
                                                     patch_size,
                                                     n_classes=num_classes)

            if save_result:
                model_name = model
                save_path = os.path.join(test_save_path, task, model_name)
                if not os.path.exists(save_path):
                    os.makedirs(save_path)
                pred_name = os.path.split(img_path)[-1].split(
                    ".nii.gz")[0] + "_" + "pred" + ".nii.gz"
                image_name = os.path.split(img_path)[-1].split(
                    ".nii.gz")[0] + "_" + "img" + ".nii.gz"
                label_name = os.path.split(img_path)[-1].split(
                    ".nii.gz")[0] + "_" + "gt" + ".nii.gz"
                pred_save_path = os.path.join(save_path, pred_name)
                image_save_path = os.path.join(save_path, image_name)
                label_save_path = os.path.join(save_path, label_name)
                nib.save(
                    nib.Nifti1Image(prediction.astype(np.float32), np.eye(4)),
                    pred_save_path)
                # # image只保留一个模态
                nib.save(
                    nib.Nifti1Image(image[0].astype(np.float32), np.eye(4)),
                    image_save_path)
                nib.save(
                    nib.Nifti1Image(label[:].astype(np.float32), np.eye(4)),
                    label_save_path)

        print("<<<<<<<<<<<<<<<<<<<<Inference Complete<<<<<<<<<<<<<<<<<<<<" +
              "\n")

    else:

        print("<<<<<<<<<<<<<<<<<<<<Waiting For Inference<<<<<<<<<<<<<<<<<<<<" +
              "\n")

        for index, img_path in enumerate(tqdm(img_path_list)):
            image = utils.dataset.read_nifti_seg_file(img_path)

            prediction, score_map = test_single_case(net,
                                                     image,
                                                     stride_xy,
                                                     stride_z,
                                                     patch_size,
                                                     n_classes=num_classes)

            if save_result:
                model_name = model
                save_path = os.path.join(test_save_path, task, model_name)
                if not os.path.exists(save_path):
                    os.makedirs(save_path)
                pred_name = os.path.split(img_path)[-1].split(
                    ".nii.gz")[0] + "_" + "pred" + ".nii.gz"
                image_name = os.path.split(img_path)[-1].split(
                    ".nii.gz")[0] + "_" + "img" + ".nii.gz"

                pred_save_path = os.path.join(save_path, pred_name)
                image_save_path = os.path.join(save_path, image_name)

                nib.save(
                    nib.Nifti1Image(prediction.astype(np.float32), np.eye(4)),
                    pred_save_path)
                # # image只保留一个模态
                nib.save(
                    nib.Nifti1Image(image[0].astype(np.float32), np.eye(4)),
                    image_save_path)

        print("<<<<<<<<<<<<<<<<<<<<Inference Complete<<<<<<<<<<<<<<<<<<<<" +
              "\n")


def SegTest():
    net.load_state_dict(torch.load(model_path))
    test_all_case(net,
                  test_path,
                  patch_size=(img_size[0], img_size[1], img_size[2]),
                  stride_xy=32,
                  stride_z=16,
                  save_result=True,
                  test_save_path=test_save_path)


def xus_segtest(test_dir, test_files, test_model_params):
    net.load_state_dict(torch.load(test_model_params))
    total_average_distance_gt2pred = []
    total_average_distance_pred2gt = []
    total_dice_coefficient = []

    for file in test_files:
        tmp_img = os.path.join(test_dir, file["image"])
        tmp_label = os.path.join(test_dir, file["label"])
        img_label_dict = {"image": tmp_img, "label": tmp_label}

        test_dataset = XusCTSegDataset(img_label_dict)
        testloader = data.DataLoader(test_dataset, batch_size, num_workers=3)

        for images, labels in tqdm(testloader):
            images, labels = images.to(DEVICE), labels.to(DEVICE)
            images = images.half()
            outputs = net(images)
            outputs = torch.argmax(outputs.data, dim=1)

            labels = labels.cpu().detach().numpy()
            outputs = outputs.cpu().detach().numpy()

            if outputs.ndim == 4:
                for pred, ground in zip(outputs, labels):
                    current_surface_distance = compute_surface_distances(
                        mask_gt=ground, mask_pred=pred, spacing_mm=(3, 2, 1))

                    current_average_surface_distance = compute_average_surface_distance(
                        current_surface_distance)

                    current_average_surface_distance_gt2pred, current_average_surface_distance_pred2gt = current_average_surface_distance

                    current_dice_coefficient = compute_dice_coefficient(
                        mask_gt=ground, mask_pred=pred)

                    total_average_distance_gt2pred.append(
                        current_average_surface_distance_gt2pred)
                    total_average_distance_pred2gt.append(
                        current_average_surface_distance_pred2gt)

                    total_dice_coefficient.append(current_dice_coefficient)

            elif outputs.ndim == 3:
                current_surface_distance = compute_surface_distances(
                    mask_gt=labels, mask_pred=outputs, spacing_mm=(3, 2, 1))

                current_average_surface_distance = compute_average_surface_distance(
                    current_surface_distance)

                current_average_surface_distance_gt2pred, current_average_surface_distance_pred2gt = current_average_surface_distance

                current_dice_coefficient = compute_dice_coefficient(
                    mask_gt=labels, mask_pred=outputs)

                total_average_distance_gt2pred.append(
                    current_average_surface_distance_gt2pred)
                total_average_distance_pred2gt.append(
                    current_average_surface_distance_pred2gt)

                total_dice_coefficient.append(current_dice_coefficient)

            else:
                raise ValueError("The outputs has n-dim: ", outputs.ndim)


test_dir = param["data_path"]
test_model_params = testing_param["model_path"]
test_files = testing_param["test_path"]

if __name__ == "__main__":
    if task == "classification":
        # ClsTest()
        xus_clstest(test_dir, test_files, test_model_params)
    if task == "segmentation":
        # SegTest()
        xus_segtest(test_dir, test_files, test_model_params)